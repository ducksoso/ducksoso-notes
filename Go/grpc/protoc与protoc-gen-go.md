`protoc & protoc-gen-go`



#### 1、`protoc-gen-go`安装

`Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data.`

`protobuf`是`google` 的一种数据交换的格式，它独立于语言，独立于平台。`google` 提供了多种语言的实现：`java、c#、c++、go` 和 `python`，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 `xml` 进行数据交换快许多。（也就是说，当服务器端使用`go`实现，注册了`api`；那么客户端是`python`实现，通过`Protobuf`也可以实现远程访问）

1. `protoc`是`Protobuf`编译器，可以直接从`github`上下载源码，地	址：`https://github.com/google/protobuf/releases/*`

   1、直接将`protoc-xxx.zip`包解压到`/usr/local/`目录下，执行命令如下：

   `unzip protoc-xxx.zip -d /usr/local/`，此时，在`/usr/local/bin`下就会出现`protoc`

   

   2、亦可以手动编译：

   ```shell
   git clone https://github.com/google/protobu
   ./autogen.sh   # 生成 configure 文件
   ./configure
   make
   make check
   sudo make install
   sudo ldconfig
   ```

   注意：安装完成之后，会在`/usr/lib`目录下生成前缀为`libprotobuf、libprotobuf-lite、libprotoc`这三类静态和动态库文件。

   然后，需要执行`ldconfig`来更新`lib`路径。

   如果上述步骤完成之后，执行`protoc`时仍然发生错误的话，可以按照如下方式手动链接

   `ls -s /usr/lib/libprotobuf.so.10.0.0 /usr/lib/libprotobuf.so`

   

   3、直接通过`homebrew`进行安装 - Mac 下

   ​	`brew install protobuf`

2. `protoc-gen-go`是`go`版本的`Protobuf`编译器插件

   `go get -u github.com/golang/protobuf/protoc-gen-go`即可在`$GOPATH/bin`目录下发现这个工具

**小结：**

​	要想使用`Protobuf`作为数据交换格式，必须有两个前提：`protoc`编译器 & `protoc-gen-go`插件



#### 2、`protoc-gen-go`使用

**语法：**

`protoc [OPTION] PROTO_FILES`

`protoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/addressbook.proto `

`protoc --go_out=. hello.proto`

**参数说明：**

1. `--go_out=$DST_DIR`：指定输出`go`代码的目录

2. `go_out`参数告知`protoc`编译器去加载对应的`protoc-gen-go`工具，然后通过该工具生成代码，生成代码放到`$DST_DIR`目录。

3. `-I=$SRC_DIR`：指定`proto`文件搜索目录

4. `$SRC_DIR/addressbook.proto `：指定`proto`文件的位置



如果多个`proto`文件之间有互相依赖，生成某个`proto`文件的时候，需要`import`其他的`proto`文件，这时候就需要用`-I`来指定搜索目录。

```
Specify the directory in which to search for imports. May be specified multiple times; directories will be searched in order. If not given, the current working directory is used.
```

可以指定多个`-I`，如果不指定的话，就采用当前目录。



#### 3、生成`rpc`服务代码

默认定义的`proto`文件，在使用`protoc-gen-go`的时候只会生成`message`相关代码，不会生成`rpc`相关代码。

`Protobuf`的`protoc`编译器是通过插件机制实现对不同语言的支持。比如protoc命令出现`--xxx_out`格式的参数，那么protoc将首先查询是否有内置的xxx插件，如果没有内置的xxx插件那么将继续查询当前系统中是否存在protoc-gen-xxx命名的可执行程序，最终通过查询到的插件生成代码。对于Go语言的protoc-gen-go插件来说，里面又实现了一层静态插件系统。比如protoc-gen-go内置了一个gRPC插件，用户可以通过`--go_out=plugins=grpc`参数来生成gRPC相关代码，否则只会针对message生成相关代码。

参考`gRPC`插件的代码，可以发现`generator.RegisterPlugin`函数可以用来注册插件。插件是一个`generator.Plugin`接口：

```go
// A Plugin provides functionality to add to the output during
// Go code generation, such as to produce RPC stubs.
type Plugin interface {
    // Name identifies the plugin.
    Name() string
    // Init is called once after data structures are built but before
    // code generation begins.
    Init(g *Generator)
    // Generate produces the code generated by the plugin for this file,
    // except for the imports, by calling the generator's methods P, In,
    // and Out.
    Generate(file *FileDescriptor)
    // GenerateImports produces the import declarations for this file.
    // It is called after Generate.
    GenerateImports(file *FileDescriptor)
}
```

可以自己设计一个`netrpcPlugin`插件，用于标准库的`RPC`框架生成代码。

1. 将生成的可执行程序命名为：`protoc-gen-go-netrpc`，表示包含了`netrpc`插件。

2. 使用命令如下

   `protoc -go-netrpc_out=plugins=netrpc:. hello.proto`

   其中`--go-netrpc_out`参数告知`protoc`编译器加载名为`protoc-gen-go-netrpc`的插件，插件中的`plugins=netrpc`指示启用内部唯一的名为`netrpc`的`netrpcPlugin`插件。



#### 4、 `protoc-gen-go`生成`grpc`相关代码

`protoc --go_out=plugins=grpc:. *.proto`

* `plugins=plugin1,plugin2`：指定要加载的子插件列表

  需要给`plugins`参数传递给`protoc-gen-go`，告诉它，请支持`grpc`

* `--go_out=.`：设置`Go`代码输出的目录

* `:`：冒号

  冒号充当分隔符的作用，后跟所需要的参数集。其实就是区分：`plugins` & `.`









https://segmentfault.com/a/1190000021456180